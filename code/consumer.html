<!DOCTYPE html>
<html lang="en">
  <head>
    <title>API Documentation for Consumer - NoTrace
    </title>
    <script type="text/javascript">var ghuser = 'rstuven'
  , ghproject = 'node-notrace';

</script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
    <script src="/node-notrace/public/js/jq-mousewheel.js"></script>
    <script src="/node-notrace/public/js/antiscroll.js"></script>
    <script src="/node-notrace/public/js/prettify.js"></script>
    <script src="/node-notrace/public/js/main.js"></script>
    <link rel="stylesheet" href="/node-notrace/public/css/antiscroll.css" type="text/css" media="all">
    <link rel="stylesheet" href="/node-notrace/public/css/main.css" type="text/css" media="all">
    <link href="http://fonts.googleapis.com/css?family=Lato:300|Redressed" rel="stylesheet" type="text/css">
  </head>
  <body>
    <nav>
      <div class="box-wrap antiscroll-wrap">
        <div class="box">
          <div class="antiscroll-inner">
            <div class="box-inner">
              <ul class="sections">
              </ul>
            </div>
          </div>
        </div>
      </div>
      <ul class="pages">
        <li><a href="/node-notrace">Home</a>
        </li>
      </ul>
      <ul class="code">
        <li><a href="/node-notrace/code/consumer.html">Consumer</a>
        </li>
        <li><a href="/node-notrace/code/provider.html">Provider</a>
        </li>
        <li><a href="/node-notrace/code/probe.html">Probe</a>
        </li>
      </ul>
    </nav>
    <header>
      <h1><a href="/node-notrace">NoTrace</a>
      </h1>
      <div class="description"><p>Probing and monitoring library based on AMQP.</p>

      </div>
    </header>
    <section id="content">
      <div id="code">
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>Consumer</h1>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;class</span><span class="desc">Consumer</span>
            </div>
          </div>
          <div class="description"><p>This class enables specific probes, receives samples and provide facilities for aggregation of samples.</p>
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>exports.Consumer = Consumer = (function() {</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><p>@constructor</p>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">config</span><span class="desc">(Optional) The configuration object.</span>
            </div>
          </div>
          <div class="description">
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>var generateObservable, pairAggregation;

    function Consumer(config) {
      this.config = config != null ? config : {};
      this.id = uuid();
      this.reconnectTimer = new Timer;
      this.requestEnableTimer = new Timer;
      this.connectionEndDelay = new Delay;
    }</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.sample()</h1>

<p>Requests a single sample using probe key.</p>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">probeKey</span><span class="desc">The probe key with the format &quot;provider.module.probe&quot;.</span>
            </div>
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">callback</span><span class="desc">The callback function receives a 'subject' argument.</span>
            </div>
          </div>
          <div class="description">
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>Consumer.prototype.sample = function(probeKey, callback) {
      var _this = this;
      return this.start(probeKey, function(subject) {
        return subject.subscribe(function(x) {
          callback(x);
          return _this.stop();
        });
      });
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.start() [1]</h1>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; String &#125;</span><span class="name">probeKey</span><span class="desc">The probe key with the format &quot;provider.module.probe&quot;.</span>
            </div>
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Function &#125;</span><span class="name">callback</span><span class="desc">The callback function receives a 'subject' argument.</span>
            </div>
          </div>
          <div class="description"><p>Starts a subscription to samples using probe key.</p>

<p>A probe key has the format <code>provider.module.probe</code> and allows to use a <code>*</code> wildcard instead of each part. For example, the probe key <code>*.*.uptime</code> matches any probe named "uptime" of any provider in any module.</p>

<p>The callback function receives a <code>subject</code> argument. Subject is an RxJS object that allows to subscribe to a stream of samples and processing them as they arrive using a powerful API.</p>

<h2>Examples</h2>

<p>Receive a stream of samples.</p>

<pre><code>consumer.start('*.*.myprobe', function (subject) {
  subject.subscribe(function (sample) {
    console.log(sample); // prints all arriving samples
  });
});
</code></pre>

<p>Calculate an average per second.</p>

<pre><code>consumer.start('*.*.myprobe', function (subject) {
  subject
    .select(function (x) { return x.args[0]; })
    .windowWithTime(1000)
    .selectMany(function (win) { return win.average(); })
    .subscribe(function (x) { console.log(x); }); // prints a number every second
});
</code></pre>

<p>Calculate an average per second per module. Now this requires a little more involved use of bare RxJS. This can be simplified a lot using a <code>callbackConfig</code>.</p>

<pre><code>consumer.start('*.*.myprobe', function (subject) {
  subject
    .windowWithTime(1000)
    .selectMany(function (win) {
      var agg = win
        .groupBy(function (x) { return x.module; })
        .selectMany(function (grp) {
          return grp.count().select(function (x) { return { module: grp.key, count: x }; }).zip(
                 grp.select(function (x) { return x.args[0]; }).average(),
                     function (f, r) { f.average = r; return f; });
        })
        .aggregate([], function (acc, x) { acc.push(x); return acc; });
      return agg;
    })
    .subscribe(function (x) { console.log(x); });
    // prints every second something like: [ {module:'a', average: 123}, {module:'b', average: 456} ]
});
</code></pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.start() [2]</h1>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">probeConfig</span><span class="desc">The probe configuration object.</span>
            </div>
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">callbackConfig</span><span class="desc">The callback configuration object.</span>
            </div>
          </div>
          <div class="description"><p>Starts a subscription to samples using configuration objects.</p>

<p><em>callbackConfig</em> argument can have the following properties:</p>

<ul>
<li><code>mapbefore</code>: {String} Map expression before grouping and aggregating, evaluated right after <code>filterbefore</code>.</li>
<li><code>mapafter</code>: {String} Map expression after grouping and aggregating, evaluated right before the callback.</li>
<li><code>filterbefore</code>: {String} Filter using boolean expression at the beginning.</li>
<li><code>filterafter</code>: {String} Filter using boolean expression, evaluated right before <code>mapafter</code>.</li>
<li><code>aggregate</code>: {String} Aggregate function over expression.
<ul><li>Available aggregation functions are:</li>
<li><em>count()</em></li>
<li><em>sum(expression)</em></li>
<li><em>min(expression)</em></li>
<li><em>max(expression)</em></li>
<li><em>average(expression)</em></li>
<li><em>quantize(expression)</em></li>
<li><em>lquantize(expression; lowerBound; upperBound; stepValue)</em></li>
<li>Using <code>pair</code>, available aggregations are:</li>
<li><em>elapsed_time()</em></li>
<li><em>delta(expression)</em></li>
<li><em>fraction(expression)</em></li>
<li><em>rate_per_millisecond(expression)</em></li>
<li><em>rate_per_second(expression)</em></li>
<li><em>average(expression1, expression2)</em></li>
<li><em>average_timer(expression1, expression2)</em></li>
<li><em>multi_timer(expression1, expression2)</em></li>
<li><em>multi_timer_inverse(expression1, expression2)</em></li></ul></li>
<li><code>aggregate2</code>: {String} Aggregate function to apply after <code>aggregate</code> with <code>pair</code>. Requires no <code>group</code> be specified.</li>
<li><code>group</code>: {String} Group expression.</li>
<li><code>window</code>: {String} Time window in the format <code>span[,shift]</code>. <code>span</code> is the length of each window. <code>[,shift]</code> is the optional interval between creation of consecutive windows.</li>
<li><code>pair</code>: {Boolean} Pair previous and current sample. Requires <code>aggregate</code> and no <code>group</code> be specified.</li>
<li><code>callback</code>: {Function} Callback function that receives result of processing.</li>
</ul>

<p>Expressions required above are strings containing JavaScript expressions. Sample properties are available as variables, unless a mapping or aggregating operation is applied.</p>

<h2>Examples</h2>

<p>During 5 seconds, count how many samples per module there are:</p>

<pre><code>consumer.start('*.*.random_walk', {
    aggregate: 'count()',
    group: 'module',
    callback: function(result) { console.log(result); }
});
consumer.stop({wait: 5000});
</code></pre>

<p>During 1500 ms, every 500 ms, take a 1 second of samples, group them by module and average the first argument:</p>

<pre><code>consumer.start('*.*.random_walk', {
    aggregate: 'average(args[0])',
    group: 'module',
    window: '1000,500',
    callback: function(result) { console.log(result); }
});
consumer.stop({wait: 1500});
</code></pre>

<p>During 1 second, calculate the differences between a value and the next, then aggregate them all using quantize:</p>

<pre><code>consumer.start('*.*.random_walk', {
    pair: true,
    aggregate: 'delta(args[0])',
    aggregate2: 'quantize',
    callback: function(result) { console.log(result); }
});
consumer.stop({wait: 1000});
</code></pre>

<p>During 1 second, filter all values below 20, count per every 100 ms, filter counts above 0:</p>

<pre><code>consumer.start({
  probeKey: '*.*.random',
  sampleInterval: 1 // request the matching probes to emit a sample every 1 millisecond.
}, {
    filterbefore: 'args[1] &lt; 20',
    window: '100',
    aggregate: 'count()',
    filterafter: 'count &gt; 0',
    callback: function(sample) { console.log(sample); }
});
consumer.stop({wait: 1000});
</code></pre>
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>Consumer.prototype.start = function(config, callback) {
      var probeKey,
        _this = this;
      if (this.isBusy()) throw new Error('Consumer is busy. It must stop first.');
      if (typeof callback === 'object') {
        this.start(config, function(subject) {
          return generateObservable(callback, subject).subscribe(callback.callback);
        });
        return;
      }
      if (typeof config === 'string') {
        probeKey = config;
      } else {
        probeKey = config.probeKey;
      }
      if ((config != null) &amp;&amp; (config.sampleInterval != null)) {
        this.sampleInterval = config.sampleInterval;
      } else {
        this.sampleInterval = REQUEST_SAMPLE_INTERVAL;
      }
      probeKey = probeKey.replace(/^\./, '*.');
      probeKey = probeKey.replace(/\.$/, '.*');
      probeKey = probeKey.replace(/\.\./, '.*.');
      this.probeKey = probeKey;
      this.subject = new rx.Subject;
      callback(this.subject);
      this.connect();
      return this.reconnectTimer.start(RECONNECT_INTERVAL, function() {
        if (!(_this.connection != null)) return _this.connect();
      });
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.stop()</h1>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Object &#125;</span><span class="name">config.</span><span class="desc"></span>
            </div>
          </div>
          <div class="description"><p>Stops the current subscription to samples.</p>

<p>It can be configured to wait a time before stopping (by default is immediate) and disconnect right away (by default, the connections remains open for some time, which is good for new subscriptions but a console application, for example, won't exit until the connection ends).</p>

<h2>Examples</h2>

<pre><code>consumer.stop(); // stop receiving samples, stay connected for the next subscription.

consumer.stop({
    wait: 5000, // stop after 5 seconds.
    disconnect: true
});
</code></pre>
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>Consumer.prototype.stop = function(config) {
      var wait,
        _this = this;
      if (config == null) config = {};
      if (config.wait != null) {
        wait = config.wait;
        delete config.wait;
        setTimeout(function() {
          return _this.stop(config);
        }, wait);
        return;
      }
      this.reconnectTimer.stop();
      this.requestEnableTimer.stop();
      this.request(this.probeKey, 'stop');
      if (this.subject != null) {
        this.subject.onCompleted();
        this.subject = null;
      }
      if (this.queue != null) {
        this.queue.destroy();
        this.queue = null;
      }
      return this.disconnect(config.disconnect === true);
    };

    Consumer.prototype.request = function() {
      var args, message, probeKey, request;
      probeKey = arguments[0], request = arguments[1], args = 3 &lt;= arguments.length ? __slice.call(arguments, 2) : [];
      if (!(this.requests != null)) return;
      message = {
        request: request,
        probeKey: probeKey,
        consumerId: this.id,
        args: args
      };
      message = BSON.serialize(message);
      try {
        return this.requests.publish(probeKey, message);
      } catch (e) {
        return this.disconnect();
      }
    };

    Consumer.prototype.connect = function() {
      var host,
        _this = this;
      this.connectionEndDelay.stop();
      if (this.connection != null) {
        this.open();
        return;
      }
      host = this.config.host || 'localhost';
      this.connection = amqp.createConnection({
        host: host
      });
      this.connection.on('error', function(err) {
        console.error(err);
        return _this.disconnect();
      });
      return this.connection.on('ready', function() {
        return _this.open();
      });
    };

    Consumer.prototype.open = function() {
      var _this = this;
      return exchanges.requests(this.connection, function(exchange) {
        if (!(_this.connection != null)) return;
        _this.requests = exchange;
        _this.request(_this.probeKey, 'enable', _this.sampleInterval);
        _this.requestEnableTimer.start(REQUEST_ENABLE_INTERVAL, function() {
          return _this.request(_this.probeKey, 'enable', _this.sampleInterval);
        });
        return exchanges.samples(_this.connection, function(exchange) {
          if (!(_this.connection != null)) return;
          _this.samples = exchange;
          return _this.connection.queue('', function(queue) {
            if (!(_this.connection != null)) return;
            _this.queue = queue;
            queue.bind(_this.samples.name, _this.probeKey + '.' + _this.id);
            queue.subscribe({
              ack: false,
              exclusive: true
            }, function(message) {
              message = BSON.deserialize(message.data);
              if (_this.subject != null) return _this.subject.onNext(message);
            });
            return _this.request(_this.probeKey, 'sample');
          });
        });
      });
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.disconnect()</h1>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;param</span><span class="types">&#123; Boolean &#125;</span><span class="name">immediate</span><span class="desc">Specifies whether to disconnect immediately or to wait a few seconds</span>
            </div>
          </div>
          <div class="description"><p>Disconnects from server.</p>
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>Consumer.prototype.disconnect = function(immediate) {
      var _this = this;
      if (immediate == null) immediate = true;
      if (this.samples != null) this.samples = null;
      if (this.requests != null) this.requests = null;
      this.connectionEndDelay.stop();
      if (immediate) {
        if (this.connection != null) {
          this.connection.end();
          return this.connection = null;
        }
      } else {
        return this.connectionEndDelay.start(CONNECTION_END_WAIT, function() {
          if (_this.connection != null) {
            _this.connection.end();
            return _this.connection = null;
          }
        });
      }
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>.isBusy()</h1>

<p>Gets the busy state. When a subscription starts, we say the consumer is busy. When the subscription stops, the consumer is not busy.</p>
          </div>
          <div class="tags">
            <div class="tag"><span class="type">&#64;return</span><span class="desc"></span>
            </div>
          </div>
          <div class="description">
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>Consumer.prototype.isBusy = function() {
      return this.subject != null;
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>RxJS query generation.</h1>

<p>Please, view source.</p>
          </div>
          <div class="description">
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>generateObservable = function(config, subject) {
      var aggBy, aggBy2, aggCode, aggFn, aggMatches, aggName, code, expression, func, globalProp, globalProps, groupCode, highlight, windowCode;
      expression = function(e) {
        return &quot;function(_){return(function(){with(_){return &quot; + (highlight(e)) + &quot;;}}).call(global);}&quot;;
      };
      highlight = function(c) {
        if (c != null) return c.grey;
      };
      code = '';
      globalProps = (function() {
        var _results;
        _results = [];
        for (globalProp in global) {
          if (globalProp !== 'console') _results.push(globalProp);
        }
        return _results;
      })();
      code += &quot;\nvar &quot; + (globalProps.join(',')) + &quot;;&quot;;
      code += '\nglobal = {};';
      code += '\nvar s = subject;';
      if (config.filterbefore != null) {
        code += &quot;s = s.where(&quot; + (expression(config.filterbefore)) + &quot;);&quot;;
      }
      if (config.mapbefore != null) {
        code += &quot;s = s.select(&quot; + (expression(config.mapbefore)) + &quot;);&quot;;
      }
      if (config.aggregate != null) {
        aggMatches = config.aggregate.match(/^\s*([^\(]+)\(([^;]*)(?:;(.*))?\)\s*$/);
        if (!(aggMatches != null)) throw new Error(&quot;Invalid aggregate format&quot;);
        aggFn = aggMatches[1];
        aggBy = aggMatches[2];
        aggBy2 = aggMatches[3];
        if (aggBy2 != null) aggBy2 = aggBy2.replace(/;/g, ',');
        if ((aggBy != null) &amp;&amp; aggBy.trim() !== '') {
          aggCode = &quot;.select(&quot; + (expression(aggBy)) + &quot;)&quot;;
        } else {
          aggCode = &quot;&quot;;
        }
        aggCode += &quot;.&quot; + (highlight(aggFn)) + &quot;(&quot; + (highlight(aggBy2)) + &quot;)&quot;;
        aggName = aggFn;
      } else {
        aggCode = &quot;.take(1)&quot;;
        aggName = &quot;sample&quot;;
      }
      if (config.group != null) {
        groupCode = aggCode;
        groupCode += &quot;.select(function(_){return {key:grp.key, &quot; + (highlight(aggName)) + &quot;:_};})&quot;;
        windowCode = &quot;.groupBy(&quot; + (expression(config.group)) + &quot;)&quot;;
        windowCode += &quot;.selectMany(function(grp){return grp&quot; + groupCode + &quot;;})&quot;;
        if (config.filterafter != null) {
          windowCode += &quot;.where(&quot; + (expression(config.filterafter)) + &quot;)&quot;;
        }
        windowCode += &quot;.aggregate([], function(acc, _){ acc.push(_); return acc;})&quot;;
      } else if (config.pair) {
        windowCode = &quot;.take(1)&quot;;
      } else {
        windowCode = aggCode;
        if (config.aggregate != null) {
          windowCode += &quot;.select(function(_){return {&quot; + (highlight(aggName)) + &quot;:_};})&quot;;
        }
      }
      if (config.window != null) {
        code += &quot;s = s.windowWithTime(&quot; + (highlight(config.window)) + &quot;);&quot;;
        code += &quot;s = s.selectMany(function(win){return win&quot; + windowCode + &quot;;});&quot;;
      } else if ((config.aggregate != null) &amp;&amp; !config.pair) {
        code += &quot;s = s&quot; + windowCode + &quot;;&quot;;
      }
      if ((config.aggregate != null) &amp;&amp; config.pair &amp;&amp; !(config.group != null)) {
        code += &quot;s = s.zip(s.skip(1), function(p,c){return {prev:p, cur:c};});&quot;;
        code += &quot;s = s.select(function(_){return pairAggregation('&quot; + (highlight(aggFn)) + &quot;'&quot;;
        code += &quot;,&quot; + (expression(aggBy));
        code += &quot;,&quot; + (expression(aggBy2));
        code += &quot;,_.prev, _.cur);});&quot;;
        if (config.aggregate2 != null) {
          code += &quot;s = s.&quot; + (highlight(config.aggregate2)) + &quot;().select(function(_){return {\&quot;&quot; + (highlight(config.aggregate2)) + &quot; &quot; + (highlight(aggFn)) + &quot;\&quot;:_};});&quot;;
        } else {
          code += &quot;s = s.select(function(_){return {&quot; + (highlight(aggFn)) + &quot;:_};});&quot;;
        }
      }
      if ((config.filterafter != null) &amp;&amp; !(config.group != null)) {
        code += &quot;s = s.where(&quot; + (expression(config.filterafter)) + &quot;);&quot;;
      }
      if (config.mapafter != null) {
        code += &quot;s = s.select(&quot; + (expression(config.mapafter)) + &quot;);&quot;;
      }
      code += &quot;\nreturn s;&quot;;
      code = code.replace(/(s = s\.)/g, '\n$1');
      code = code.stripColors;
      func = new Function('subject', 'pairAggregation', code);
      return func.call({}, subject, pairAggregation);
    };</code>
            </pre>
          </div>
        </article>
        <article id="undefined-section" class="codeblock">
          <div class="header"><h1>Pair aggregation.</h1>

<p>Please, view source.</p>
          </div>
          <div class="description">
          </div>
          <div class="view-source">View Source
          </div>
          <div class="code-wrap">
            <pre class="source prettyprint"><code>pairAggregation = function(type, nFn, dFn, sampleOld, sampleNew) {
      var d0, d1, n0, n1, t0, t1;
      n0 = nFn(sampleOld);
      n1 = nFn(sampleNew);
      d0 = dFn(sampleOld);
      d1 = dFn(sampleNew);
      t0 = sampleOld.timestamp;
      t1 = sampleNew.timestamp;
      switch (type) {
        case 'elapsed_time':
          return t1 - t0;
        case 'delta':
          return n1 - n0;
        case 'fraction':
          return n0 / d0;
        case 'average':
          return (n1 - n0) / (d1 - d0);
        case 'rate_per_millisecond':
          return (n1 - n0) / (t1 - t0);
        case 'rate_per_second':
          return (n1 - n0) / (t1 - t0) * 1000;
        case 'multi_timer':
          return (n1 - n0) / (t1 - t0) * 100 / d1;
        case 'average_timer':
          return (n1 - n0) / (t1 - t0) / (d1 - d0);
        case 'multi_timer_inverse':
          return (d1 - (n1 - n0) / (t1 - t0)) * 100;
        case 'timer_100_ns_inverse':
          return (1 - (n1 - n0) / (t1 - t0)) * 100;
      }
    };

    return Consumer;

  })();

}).call(this);</code>
            </pre>
          </div>
        </article>
      </div>
    </section>
    <footer>
      <div class="branding">NoTrace site generated by&nbsp;<a href="http://codexjs.com">codex</a>, based on chai template.

      </div>
    </footer>
  </body>
</html>