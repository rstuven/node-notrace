#!/usr/bin/env node 
// Generated by CoffeeScript 1.9.2
(function() {
  var Consumer, chalk, consumer, doTimeout, exit, program, report, util, version;

  program = require('commander');

  util = require('util');

  chalk = require('chalk');

  Consumer = require('..').Consumer;

  version = JSON.parse(require('fs').readFileSync(__dirname + '/../package.json', 'utf8')).version;

  program.version(version).usage('[command] [options]').option('-C, --nocolor', 'Disable colors.');

  Object.getPrototypeOf(program).commonOptions = function() {
    return this.option('-p, --probe [provider.module.probe]', 'Probe key. (default: *.*.*)', '*.*.*').option('-R, --report [object|pretty]', 'Report format. (default: pretty)', 'pretty');
  };

  consumer = new Consumer;

  program.command('list').description('List matching probes').commonOptions().action(function(command) {
    var matches, probeName, query;
    matches = command.probe.match(/^([^\.]*\.[^\.]*)\.?([^\.]*)$/);
    if (matches == null) {
      matches = ['', '*.*', '*'];
    }
    query = matches[1] + '._probes';
    probeName = matches[2] || '*';
    console.log("Listing probes: " + matches[1] + "." + probeName + "\n");
    consumer.start({
      probeKey: query,
      sampleInterval: 0
    }, function(subject) {
      return subject.where(function(x) {
        return probeName === '*' || probeName === x.args[0].name;
      }).select(function(x) {
        var p;
        p = x.args[0];
        return {
          provider: x.provider,
          module: x.module,
          probe: p.name,
          instant: p.instant,
          sampleThreshold: p.sampleThreshold,
          types: p.types
        };
      }).subscribe(report[command.report]);
    });
    return doTimeout(1000);
  });

  program.command('sample').description('Subscribe to probe samples').commonOptions().option('-t, --timeout [milliseconds]', 'Time to wait before disconnect. (default: Infinity)', Number).option('-m, --mapbefore <expression>', 'Map expression before processing, right after --filterbefore.').option('-M, --mapafter <expression>', 'Map expression after processing, right before the callback').option('-f, --filterbefore <expression>', 'Filter using boolean expression at the beginning.').option('-F, --filterafter <expression>', 'Filter using boolean expression right before --mapafter.').option('-a, --aggregate <function(expression)>', 'Aggregate expression.').option('-A, --aggregate2 <function>', 'Aggregate function to apply after --aggregate with --pair.\n' + '                                        Requires no --group.').option('-g, --group <expression>', 'Group expression.').option('-w, --window <span>[,shift]', 'Time window. <span> is the length of each window.\n' + '                                        [,shift] is the interval between creation of consecutive windows.').option('-i, --interval <milliseconds>', 'Sampling interval.').option('-P, --pair', 'Pair previous and current sample. Requires --aggregate and no --group.').action(function(command) {
    consumer.start({
      probeKey: command.probe,
      sampleInterval: command.interval
    }, {
      mapbefore: command.mapbefore,
      mapafter: command.mapafter,
      filterbefore: command.filterbefore,
      filterafter: command.filterafter,
      aggregate: command.aggregate,
      aggregate2: command.aggregate2,
      group: command.group,
      window: command.window,
      pair: command.pair,
      callback: report[command.report]
    });
    return doTimeout(command.timeout);
  });

  exit = function(code) {
    consumer.stop();
    consumer.disconnect();
    return process.exit(code);
  };

  doTimeout = function(timeout) {
    if (timeout == null) {
      return;
    }
    return setTimeout(function() {
      return exit(0);
    }, timeout);
  };

  process.on('SIGTERM', function() {
    return exit(1);
  });

  process.on('SIGINT', function() {
    return exit(1);
  });

  report = {
    object: function(x) {
      return console.log(util.inspect(x, false, 5, !program.nocolor));
    },
    pretty: (function() {
      var formatFirst, formatHeader, formatObject, formatQuantizer, formatValue, pad;
      formatFirst = true;
      pad = function(x, n) {
        while (x.length < Math.abs(n)) {
          if (n < 0) {
            x = ' ' + x;
          } else {
            x = x + ' ';
          }
        }
        return x;
      };
      formatHeader = function(k, v) {
        var h;
        if (typeof v === 'number') {
          h = pad(k, -15);
        } else if (typeof v === 'boolean') {
          h = pad(k, 15);
        } else {
          h = pad(k, 20);
        }
        return chalk.blue(h);
      };
      formatValue = function(v) {
        var f, r;
        if (v == null) {
          return '<undefined>';
        } else if (typeof v === 'number') {
          f = v.toFixed(3);
          if (f.slice(-3) === '000') {
            f = v.toString();
          }
          r = pad(f, -15);
          return chalk.gray(r);
        } else if (typeof v === 'string') {
          return pad(v, 20);
        } else if (typeof v === 'boolean') {
          r = pad(v.toString(), 15);
          return chalk.yellow(r);
        } else if (/Quantizer$/.test(v.constructor.name)) {
          return formatQuantizer(v);
        } else {
          return util.inspect(v, false, 5, !program.nocolor);
        }
      };
      formatQuantizer = function(q) {
        var bar, count, i, j, length, lines, ref, ref1, totalCount;
        length = 50;
        bar = function(x) {
          var j, results;
          if (q.maxCount === 0) {
            return '';
          }
          x = (length - 1) * x / q.maxCount;
          if (x === 0) {
            return pad('', length);
          }
          x = (function() {
            results = [];
            for (var j = 1; 1 <= x ? j <= x : j >= x; 1 <= x ? j++ : j--){ results.push(j); }
            return results;
          }).apply(this).map(function() {
            return '▒';
          }).join('');
          x = pad(x, length);
          return chalk.red(x);
        };
        lines = [];
        lines.push('');
        lines.push(formatHeader('value', 0) + ' ' + pad('', length) + ' ' + formatHeader('count', 0));
        totalCount = 0;
        for (i = j = ref = q.minIndex, ref1 = q.maxIndex; j <= ref1; i = j += 1) {
          count = q.count(i);
          totalCount += count;
          lines.push(formatValue(q.indexValue(i)) + '│' + bar(count) + '│' + formatValue(count));
        }
        lines.push(pad('', 15) + '│' + chalk.yellow(pad('total count ', -length)) + '│' + chalk.stripColor(formatValue(totalCount)));
        lines.push('');
        return lines.join('\n');
      };
      formatObject = function(x) {
        var head, key, line, result, v, value;
        if (x instanceof Array) {
          formatFirst = true;
          result = '';
          x.forEach(function(y) {
            return result += formatObject(y);
          });
          return result;
        }
        if (typeof x !== 'object') {
          return formatValue(x) + '\n';
        }
        head = [];
        line = [];
        for (key in x) {
          value = x[key];
          v = formatValue(value);
          if (v != null) {
            line.push(v);
            if (formatFirst) {
              head.push(formatHeader(key, value));
            }
          }
        }
        result = '';
        if (line.length !== 0) {
          if (formatFirst) {
            result += "\n";
            result += head.join(' ') + "\n";
            formatFirst = false;
          }
          result += line.join(' ') + "\n";
        }
        return result;
      };
      return function(x) {
        var result;
        result = formatObject(x);
        if (program.nocolor) {
          result = chalk.stripColor(result);
        }
        return process.stdout.write(result);
      };
    })()
  };

  program.command('*').action(function() {
    process.stdout.write(program.helpInformation());
    return process.exit(0);
  });

  program.parse(process.argv);

}).call(this);
